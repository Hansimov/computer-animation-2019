<html>
<head>
  <!-- <style>canvas {width: 100%; height: 100% }</style> -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.min.js"></script>
</head>

<body>
<canvas id="m1"></canvas>
<canvas id="m2"></canvas>
<canvas id="m3"></canvas>

<script>
    var pi=Math.PI, sin=Math.sin, cos=Math.cos;
    // Initial setup
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight*3, 0.1, 1000);
    camera.position.z = 10;

    var renderer1 = new THREE.WebGLRenderer({canvas:m1,antialias:true});
    renderer1.setSize(window.innerWidth, window.innerHeight/3);
    // document.body.appendChild(renderer.domElement);
    var renderer3 = new THREE.WebGLRenderer({canvas:m3,antialias:true});
    renderer3.setSize(window.innerWidth, window.innerHeight/3);

    var dotGeometry = new THREE.Geometry();
    var dotMaterial = new THREE.PointsMaterial({size: 0.05, sizeAttenuation: true, color:0xffff00});

    var px, py, pz, angv, angh;
    var [cx, cy, cz] = [6, 0, 0];
    var r = 1;
    var [vsegs, hsegs] = [20, 20];

    var tmpDot;
    for (var iv=-vsegs; iv<=vsegs; iv++) {
        for (var ih=-hsegs; ih<=hsegs; ih++) {
            angv = iv/vsegs * pi;
            angh = ih/hsegs * pi;
            px = cx + r * sin(angv) * cos(angh);
            py = cy + r * cos(angv);
            pz = cz + r * sin(angv) * sin(angh);
            tmpDot = new THREE.Vector3(px, py, pz);
            dotGeometry.vertices.push(tmpDot);
        }
    }

    var dots = new THREE.Points(dotGeometry, dotMaterial);
    scene.add(dots);

    var delta=0;
    var render = function() {
        requestAnimationFrame(render);
        // dots.rotation.x += 0.01;
        // dots.rotation.y += 0.02;
        dots.geometry.verticesNeedUpdate = true;

        delta = 0.1;

        // dotGeometry.vertices = [];
        for (var i=0; i<dots.geometry.vertices.length; i++) {
            var dgv = dots.geometry.vertices[i];
            dgv["x"] = dgv["x"] * cos(delta) + dgv["z"] * sin(delta);
            dgv["z"] = -dgv["x"] * sin(delta) + dgv["z"] * cos(delta);
            // console.log(dots.geometry.vertices[i][0]);
        }

        // for (var iv=-vsegs; iv<=vsegs; iv++) {
        //     for (var ih=-hsegs; ih<=hsegs; ih++) {
        //         angv = iv/vsegs * pi;
        //         angh = ih/hsegs * pi + delta/5*pi;
        //         px = cx + r * sin(angv) * cos(angh);
        //         py = cy + r * cos(angv);
        //         pz = cz + r * sin(angv) * sin(angh);
        //         tmpDot = new THREE.Vector3(px, py, pz);
        //         dotGeometry.vertices.push(tmpDot);
        //     }
        // }

        renderer3.render(scene, camera);
    }
    render();
</script>
</body>

</html>